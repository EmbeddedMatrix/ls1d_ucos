使用一段死循环代码，观察在进入main之前的 status 寄存器状态！！！

add 异常为什么可以嵌套到中断里面？？

得到ls1d执行指令的大概时间，算出由于执行而导致的延迟在什么数量级！！

观察栈在最后使用了多少（初始化部分的。），并且每个任务分配的栈是否够用？？

观察 set noat 是否对 sw AT,108(sp); \ 指令有影响？？


关于中断的原子性质的，跟栈切换原子性质。一定要再仔细仔细分析！！！！！！！！！！！！！

cpu掉电导致哪些需要重新初始化的？？ 那些又不需要的？唤醒状态下初始化的东西一定要慎之又慎！！！ TODO！！！



需要CPU休眠的过程中在休眠和睡醒的时候lcd的汉字会闪烁一下，能不能不让闪烁！？？
		发现原来lcd闪烁是在ejtag插上并且供电之后才有的。如果没有ejtag供电，并且lcd跳线正确
		是不会发生lcd闪烁的！！


interrupt.c 里面有关于timer赋值的。但是用汇编语句，不支持c里面的宏定义。可以考虑修改之~~



函数 SystemClock	TODO 初始化日期代码 按照闰月来更改日期


因为整个系统只允许一个进程使用浮点寄存器，因此在任务 初始化 stats 寄存器里面加入浮点控制位


tdc初始化代码涉及到的寄存器， cpu掉电后是否保存？？


TDCDATA	跟 TDCINFO 这两个结构体是不是有优化的余地？？


cpu睡眠2s，在睡了0.5秒之后key给唤醒了，继续运行到2s结果如何？
				在2s之前cpu睡眠了结果又如何？cpu睡眠之前需要判断下才行呀~~

timer 应该无法唤醒吧。否则！！  晕死~~~如何处理？？

如果wake 跟其他的同时把cpu唤醒呢？？


如果按键需要红外连续工作10秒钟，在这段时间内，cpu无法睡眠，wakeint中断也就无法弄了~~
	评估这10秒钟的影响，并改正过来！~~(甚至时间会更长--如果在10秒内有红外通信的话)


当设置好tdc在等待中断过程中，如果cpu没有休眠对测试结果影响大吗？


红外也可以唤醒cpu？？如果不可以那么在10秒红外时间时cpu无法休眠，此时的采样精确度是不是受到影响？？



将全局变量定义放在一个文件中！！

///////////////////////////////////////////////////////////////
有明显
调用关系的函数调用，比如说 TaskStart 调用 OSTimeDly 这个是通过a0 寄存器传递的・・~！

而在 OSTimeDly  函数里面也把 a0 作为参数来使用

但是在 TaskStart 同样一个参数为什么知道用


OS_TaskIdle ：
bfc01160:	27bdfff8 	addiu	sp,sp,-8
bfc01164:	afbe0004 	sw	s8,4(sp)
bfc01168:	03a0f021 	move	s8,sp
bfc0116c:	afc40008 	sw	a0,8(s8)
怎么访问sp寄存器指向的内容了？？？  因为OS_TaskIdle  函数有一个参数的。


汇编宏定义的关于标志寄存器设置的，各个地方都要考虑到~~！ CP0_STATUS  已经考虑到了~~！！
（只是这样每次任务切换都要把status寄存器设置一下！！！）


RESTORE_REG_RET（） 
        addu sp,116; \		还是120 ，这个比较难确定~~！！！ 经过多次反汇编分析，应该是120



函数 OSTaskStkInit 里面的
    *stk   = (INT32U)0;		/// ra  这里的ra已经修改为指向task了，虽然规定了进程不可以返回。但是如果有例外情况。
进程返回指令就是  jr	ra 。这样刚好让进程再执行一遍！！！



OS_ENTER_CRITICAL /// OS_EXIT_CRITICAL 对应的mips架构的！！
		用定义变量的方式  #define  OS_CRITICAL_METHOD    3


在函数 OS_Sched 里面，首先执行 OS_ENTER_CRITICAL ，然后OS_TASK_SW 也就是 OSCtxSw 切换到新的进程。如何离开临界区的
		 OS_ENTER_CRITICAL 在局部变量保存着status寄存器数值，并且关闭中断，但是切换的时候弹栈操作会把新进程的status寄存器
恢复，因此按照新进程status数值一般都是开中断的。
		等到这个进程再次执行的时候，则执行的第一条指令是OS_TASK_SW 的下一条指令 OS_EXIT_CRITICAL，此时就会按照局部变量
恢复status寄存器数值。 因此这里有个要求那就是这个局部变量必须在栈中被保存，并且始终保持有效！！！！！！！



宏定义 STORE_REG_RET 里面那句
        sw t0,112(sp); \			这个是不是要跟 *stk-- = (INT32U)(wSR); 对应起来~~！！
这里的 wSR 需要好好分析，仔细设置，------目前仅仅是设置为默认的设置方式。


mips处理器默认的在发生中断之后就把中断给屏蔽掉了，也就是默认的不支持中断嵌套的 ---- 已经确定。


时钟中断初始化寄存器，  函数 main ->  OSInit ->  OS_InitTimer 	在文件 Interrupt.c 
时钟中断处理函数！！！	TIMER1_INT			在文件 Interrupt.c 


and t0,t0,0xfffffffd;  \ 这样对吗？？ mips真够差劲~~！！！		功能实现方式：
	"li		$9, 0xf7ffffff;\n"
	"and	$8, $8, $9;\n"


整个系统过程中 中断开启关闭 的时刻，跟位置.
在 start.S 里面 关闭中断,然后在 OS_InitMips 把 wSR 的IE位置1，这样在任务创建的时候弹栈 wSR。任务的IE就等于1了。！！


la 指令访问的是标号相对于链接地址的值，按照网上的代码来看是对的了。~~！！ 在汇编中用la 访问全局变量！！！ 


如果中断被阻塞一段时间呢？后果如何？？可以承受阻塞多久	中断位，只要不清零中断位，一旦打开就会有中断！！


status 寄存器的IE位为1的时候就开启全局中断	1响应 0 不响应


如下中断： IRQ_HAND MY_INT[8] = {SOFT_INT, TIMER1_INT, WAKER_INT, KEY_INT, BAT_FAIL, RES_VALID, INTC, EXINT};
跟IM寄存器是如何对应的呢？？ 想法屏蔽之！！			P67 1才有中断！！ 已经在startS里面屏蔽！！


栈的位置（也就是定义的全局变量放在哪里？） ，在user.lds里面把全局变量放在了不掉电ram中。
对于任务所用的栈还是手动指定地址吧，放在掉电ram中 （4K 已经够用了）！！
	在os_cfg.h文件里面定义栈的地址，用数字固定住，放在掉电ram中。


统计一下uCos全局变量大概占用多少空间。可适当的把部分变量放到掉电ram中
		uCos占用不掉电ram不多，从0xa0001000开始的部分。具体可以看下生成的 *.map 文件。


MTC0 k1,CP0_STATUS ; \		如果后面的指令是一条跳转会不会发生中断---会不会应该没多大关系，
        jr k0; \				运行到这里时进程已经切换好了的~！


关于堆栈大小的，可以定义大小，而不是定义位置，用宏做加减法~~ 这个比较复杂，破坏封装性还是不弄了！


系统休眠唤醒之后任务有几个  0个，否则经过多次wake之后tcb早就消耗完了~
	OSTCBPrioTbl 清零，OSTCBFreeList 对应的TCB列表建立。任务重新创建！！


按键中断是不是可以唤醒cpu
		按键可以唤醒cpu的。 所以需要判断当前是什么唤醒的！！这个重要！
		温度，超声波采样的需要判断当前的时间。。！	情况有些复杂，需要仔细控制架构


while(!(ADC_CR&ADC_CR_HALT)); lcd 打印测试  循环 一般只有1次。




