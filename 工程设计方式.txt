变量跟函数名字，采用 匈牙利 命名法 与uCos保持一致，库代码需要修改下函数名字（发现部分大小写！！？？）



由于仅仅允许一个进程使用浮点寄存器，所以其它的进程在做乘除法运算的时候需要修改下，或者用其他模拟方式！！
为了减少任务的栈大小，这么做十分值得！！！



尽量保证一个进程修改全局变量。 如果2个进程都有修改那么就需要互斥体或者其他的东西了。！！


关于  键盘中断通信  的用的是 消息邮箱，并让系统依赖于一个假设的机制：

	产生中断之后在中断处理程序中 MboxPost 发送一个邮箱。 假设系统可以在再次发送之前把邮箱里面
的数据读走！！！！！！  用一些任务完成这个。


注意凡是用const标注的变量一般都不可修改，并且放在flash中。不要试图修改这些变量！！





1分钟内作为按键间隔的极限，用户不可以按键按下1分钟多再松开！！



液晶现实可以关闭的。（在多任务环境下这个不算太难，要指定lcd开启的条件才行！！）




特别要注意就是在有唤醒的情况下uCos要把一些全局变量初始化比如系统时间，内核事件等。 对于内核事件因为唤醒后

掉电ram里面的内存已经失效，所以栈也就没用了，整个系统需要从头开始执行，因此内核事件可以初始化。

但是系统时钟OSTime不可以再初始化了。丢失时间，而且导致运行错误！！
函数SystemClock
	TempTime	= OSTimeGet();
	SumTime		+= TempTime - LastTime;
导致SumTime变成负值，在无符号情况下就是最高位1了。因此系统时间变得十分的大！！！


没有支持放电，选择adc，电压采样的选择通道0



/// 这里需要暂停一下，等待wake int 产生之后才能继续往前走，因为要涉及到关中断
/// 如果继续往前走可能会因为OS_ENTER_CRITICAL 导致WAKE_INT 丢失。
/// 通过实验发现这里是 4096 的时候不可以，8192就可以了，
/// 以后如果编译为release模式还需要相应的更改这里的数值！！
可以在 WAKE_INT  里面修改变量值，在这里判断如果修改了，就。。。。
for(cpu_sr = 0;cpu_sr <= 8192; cpu_sr ++ );



注意因为系统cpu会睡眠，醒来后在wake_int里面会补偿系统时钟OSTime，但是仅仅只能补偿这个变量，
对于当前正处于ODTimeDly状态的任务，并不会减少他们的等待时间！！




对于文档要求的 可以选择mop码分别是 	即不使用巡航模式测量！！ 此时timing寄存器含义如何？？
0: 一次超声时差测量
1: 一次温度测量
其中测量事件的触发有两种方式：
1. 单次测量：软件往 StartOP 位写 1，启动 MOP 类型的测量；
2. 定时测量：开启巡航模式，硬件会根据配置，周期性地产生测量事件。

测量是非常精密的过程，对环境要求较高，因此软件最好在测量模块工作前将芯片置为休眠模式，关闭处理器系统
P20  CruiseMode 位是表示关闭巡航模式的！！


mop大于7的情况如何处理? 文档有吗？？



任务控制块属于占用内存大户，需要特别仔细的定义全局宏  OS_MAX_TASKS，这里定义了14 。一般的定义5就够了！！





 