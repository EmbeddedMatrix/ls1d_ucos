	 刚开始时后实验一些程序，lcd，和串口都可以按照程序设定要求来间隔变化。
但是到了大概5分钟之后发现程序终止。
	用ejtag调试发现此时陷入死循环，并且sp（栈）数值向下延伸一直超过  掉电ram  边界！！


用gdb demo 然后 p OSIntNesting 发现数值达到20多！！

初步推测是因为无节制的中断嵌套导致栈 被不停占用！

也就是说在中断中又产生了中断，可是跟踪分析发现在中断函数里面status寄存器EXL位都置位的。


并且有一个规律： 即都是运行了269秒之后，并且产生了若干个（大概42个）中断之后系统故障。


这个时间不会随着每个时钟节拍数目而改变（每1ms产生一次是269s，每10ms产生一次中断也是269s）



	修改程序让到了269s之后执行一个分支，在这个分支下断点。断下来之后然后观察中断（大概42个中断，

每个中断间隔10ms--之后）

在gdb下跟踪用info registers 查看各个寄存器数值。发现大概42次中断之后cause寄存器EXcCode 变成12，

以前都是0的。并且sp寄存器明显比以前的每一次都要小100多。用 p OSIntNesting  发现此时嵌套了一次中断。


关键点是 EXcCode 12，看see mips run发现这是由add指令引发的（addu指令无法引发）。


void TIMER1_INT()
{
	__asm__ volatile(
		"mfc0	$8, $11;\n"
		"li		$9, 0x13880;\n"
	    	"addu	$9, $8, $9;\n"
		"mtc0	$9, $11;\n"   /* write cp0_compare */

		 :::"$8","$9"
	);
	OSTimeTick();
}


	反汇编分析中断处理函数，跟所有调用的子函数。发现在 TIMER1_INT 里面有这么一条指令 add  $9, $8, $9。

前面一条指令 li	$9, 0x13880 ，在269s之后并且40次中断左右时候发现执行完 mfc0	$8, $11（读取compare）

之后$8 大概是7FFF5580，很有可能是在来几次中断这个数值最高位到8，也就是add  $9, $8, $9 有了进位，导致在中断

里面嵌套了异常，导致栈指针错误，然后出栈时候不确定的出栈数值！！


	通过把add修改为addu错误解决~~~~~~~~~・     一条指令调试两天~~~~~~~~~~~~~~~・


这条指令也说明了为什么不管是1ms一次时钟节拍，还是10ms一次时钟节拍 出现故障的时间是一样的`!!!!!!




